% !TeX root = dissertation.tex
\section{Introduction}

Zero-Knowledge proofs and arguments \cite{GMR85} are protocols with two parties: a Prover, and a Verifier. 
The prover's goal is to convince the verifier of the validity of an NP statement, while revealing zero additional 
information except that the statement is valid. In other words, the verifier learns nothing new, except whether 
the statement being proven is true or false. Early research proved that all languages in NP have zero-knowledge 
proof systems \cite{DBLP:conf/focs/GoldreichMW86}, sparking a long line of research into this area. Today, 
efficient zero-knowledge proofs and arguments are being used in practice, particularly in decentralized systems. \textbf{CITE}

In many cases, it is desirable to have a zero-knowledge proof for a \textit{disjunctive statement}, which is an NP 
statement with a set of clauses that are connected with logical ORs:

$$
clause_1 \lor clause_2 \lor \cdots \lor clause_n
$$

Disjunctive statements have very useful properties that occur commonly in practice, such as proving ones membership 
to a particular group, or showing the existence of a bug in a verifier's code base \cite{StackedGF}. Zero-knowledge 
becomes an important property in cases where revealing the exact clause (or clauses) that is true may reveal 
private information about the prover, such as their identity. A long line of research has focussed on how $n$ 
zero-knowledge proofs, each for one statement, can be composed into a new zero-knowledge proof of the disjunction 
of these statements. \textbf{CITE} 

In their 1994 paper, Cramer, Damg{\aa}rd, and Schoenmakers \cite{CDS94} provide a generic compiler to compose 
3-round public coin proofs of knowledge, or more succinctly (and more popularly) known as $\Sigma$-protocols. %perhaps discuss more
More recently, Goel {\em et al.} \cite{StackingSigmas} improved on this further, providing a generic compiler for a 
large class of $\Sigma$-protocols and also reducing the communication size of the resulting proof. 

While extensive research has been conducted, there is a lack of notable real-world implementations of these results
\footnote{It should be noted that Hall-Andersen \cite{MHAStackSig} has provided a benchmark of applying the compiler in 
\cite{StackingSigmas} to Schnorr's discrete log protocol \cite{Schnorr}.}. This project seeks to build upon their work by 
implementing the compilers described in \cite{CDS94} and \cite{StackingSigmas}. Once implemented, we aim to provide a 
benchmark for both protocols to explore and measure how they differ. This will hopefully provide some valuable insights 
as to how these designs perform in practice, which may in turn lead to further improvements in the future that may have a 
broad impact on existing and upcoming cryptographic systems that rely on such a use case. 

\subsection{Related work}
\label{sec:related_work}
As part of their work in \cite{StackingSigmas}, Hall-Andersen provides an implementation of the Stacking Sigmas (SS) compiler \cite{MHAStackSig}. In this implementation, they apply the SS compiler to Schnorr over Ristretto25519 to obtain efficient ring signatures from discrete log and random oracles. 

% Stacked Garbling implementation