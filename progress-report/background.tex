\section{Background}
\label{sec:background}
Here we introduce the relevant background knowledge needed to have an understanding of the project. 

\subsection{Proofs of Knowledge}
Explain transcripts, witness indistinguishable and WH protocols. Explain HVZK and SHVZK?

\subsection{Schnorr's Identification Protocol}
There are two parties in an \textit{identification scheme}, the prover $P$ and the verifier $V$, and the objective of the protocol is for the prover to convince the verifier that they are who they claim to be. More precisely, $V$ is convinced that $P$ knows the private key that corresponds to the public key of $P$. A familiar example is the standard protocol of password authentication.

Schnorr's protocol \cite{Schnorr} is an identification scheme where $P$ proves knowledge of the discrete log $x$ of a group element $H \in \G$, where $H = x \cdot G$ for some generator $G \in \G$. $(\G, +)$ is a finite abelian group with $+$ as the binary operator\footnote{We have chosen to define $\G$ with the $+$ operator because our implementation uses elliptic curves which are finite abelian groups over addition. The discrete log can be defined equivalently with multiplication like so: $h = g^x$}. The protocol relies on the assumption that finding $x$ given only $H$ and $G$ is computationally difficult -- this is not always the case. The hardness of finding the discrete log depends on the choice of group $\G$ (cite some resource or elaborate). Conversely, proving that $H = x \cdot G$ given $x$ and $G$ can be computed efficiently. 

In our implementation, we plan to use the Ristretto group \cite{ristretto_web}: a construction of a prime order group from a family of elliptic curves known as Edwards curves \cite{Edwards2007}. 

\textbf{Definition of Schnorr's protocol \cite{Schnorr}.} Let $\G = E(\F_q)$, where $E$ is an elliptic curve over the finite field $\F_q$. Suppose that both the prover $P$ and verifier $V$ agree on $E$ and $\F_q$, then let $H \in E(\F_q)$ be the public key that corresponds to the private key $x$ such that $H = x \cdot G$. The prover convinces the verifier that they have knowledge of the private key by doing the following:

\begin{enumerate}
    \item $P$ generates random $r \in \F_q$, and computes the point $U = r \cdot G$. $P$ sends the point $U$ to $V$.
    \item $V$ computes a random $c \in \F_q$, and sends $c$ to the $P$.
    \item $P$ computes $z = (r + c \cdot x_P) \mod n$, and sends $z$ to the $V$.
    \item $V$ checks that $z \cdot G = U + c \cdot H$.
\end{enumerate} 

Evaluating the final equation, we can easily see that $V$ accepts if and only if $x = x_P$. 

\begin{equation*}
    z \cdot G = U + c \cdot H \iff
    r \cdot G + c \cdot x_P \cdot G  = r \cdot G + c \cdot x \cdot G \iff
    x  =  x_P
\end{equation*}

\subsubsection{The Simulator}
Every zero-knowledge proof requires an efficient algorithm, called \textit{the simulator}, that given only the statement to be proven as input produces a distribution over transcripts that is indistinguishable from the distribution over transcripts when a verifier interacts with an honest prover \cite{PAZK}. (Could explain why we need the idea of a simulator and how it relates to how the verifier will learn from the prover only what it can already learn on its own = zk)

\textbf{A simulator for Schnorr's protocol.} We construct a simulator for Schnorr's protocol by running it "in reverse":

\begin{center}
    \begin{problem}[]{Let our simulator be $S(H)$}
    $z \randselect \F_q$ ($\randselect$ = select randomly from)
    
    $c \randselect \F_q$
    
    $U = z \cdot G - c \cdot H$
    \tcblower
    \textbf{output} $(U,c,z)$
    \end{problem}
\end{center}

Since $z$ and $c$ are both chosen randomly, the resulting $U$ is also random, and our output will have the same distribution as the distribution over transcripts in an actual interaction.

\subsection{Shamir's Secret Sharing Scheme}
A \textit{secret sharing scheme} is a method of distributing a secret $s$ to $n$ participants in a way that no one participant has intelligible information about the secret. This is achieved by splitting up $s$ into \textit{shares}, distributing one share to each participant in a way that a subset of participants can reconstruct $s$. Subsets that can reconstruct the secret are called \textit{qualified sets}. For \textit{perfect} secret sharing schemes, like Shamir's, participants in the complement \textit{non-qualified} sets cannot obtain any information about the secret.

Shamir's secret sharing scheme \cite{DBLP:journals/cacm/Shamir79} is also what is known as a \textit{threshold sharing scheme}. These are schemes that produce  qualified sets of size $d$. Any $d$ out of $n$ participants can reconstruct the secret; with $d-1$ shares and less, no  information about the secret can be obtained. 

\subsection{CDS94 Compiler}


In our implementation, we will use Schnorr's discrete log protocol over Ristretto25519 and Shamir's secret sharing scheme to demonstrate the compilation of $\Sigma$-protocol into a disjunctive/threshold $\Sigma$-protocol for $n$ statements. 

We will attempt to make the implementation as general as possible to open up for the future possibiity to take any $\Sigma$-protocol that suits our requirements and transform it into a $\Sigma$-protocol for $n$ statements.  

\subsubsection{The Witness Indistinguishable (WI) compilation}

In their paper, Cramer {\em{et al}} \cite{CDS94} presents 2 primary ways to construct a WI protocol from a $\Sigma$-protocol $\mathcal P$ (Theorem 8 and 9). 

\begin{itemize}
    \item Theorem 8 requires a smooth secret sharing scheme, and a HVZK $\Sigma$-protocol, while
    \item Theorem 9 requires special honest-verifier ZK (SHVZK) with at least a semi-smooth secret sharing scheme.
\end{itemize}

Since, SSS is a smooth threshold secret sharing scheme (required for 8), and Schnorr's protocol is SHVZK (required for 9), we can choose either construction. 
\textit{We will use \textbf{Theorem 8} in this project.}

\textbf{Theorem 8 \cite{CDS94}}. Given $\mathcal P$, $R_\Gamma$, $\Gamma$, and $\mathcal S(k)$ where

\begin{itemize}
    \item $\mathcal P$ is a 3-round public coin ($\Sigma$-protocol) HVZK proof of knowledge for relation $R$, which satisfies the special soundness property.
    \item $\Gamma = \{ \Gamma(k) \}$ is a family of monotone access structures
    \item $\{\mathcal S(k)\}$ is a family of smooth secret sharing schemes such that the access structure of $\mathcal S(k)$ is $\Gamma(k)^*$
    \item $R_\Gamma$ is a relation where $((x_1,\ldots,x_m),(w_1,\ldots,w_m)) \in R_\Gamma$ if and only if ($\iff$)
    \begin{itemize}
        \item all $x_i$'s are of the same length $k$, and 
        \item the set of indices $i$ for which $(x_i,w_i) \in R$ corresponds to a qualified set in $\Gamma(k)$
    \end{itemize}
\end{itemize}

Then, there exists a $\Sigma$-protocol that is witness indistinguishable for the relation $R_\Gamma$. (The proof of Theorem 8 and 9 is given in their paper.)

\subsubsection{Protocol Description}
Let $A \in \Gamma$ denote the set of indices $i$ for which our prover $P$ knows a witness for $x_i$

\begin{enumerate}
    \item For each $i \in \bar A$, $P$ runs a simulator on input $x_i$ to produce transcripts of conversations in the form $(m_1^i, c_i, m_2^i)$.
    \begin{itemize}
        \item For each $i \in A$, $P$ inputs the witness $w_i$ for $x_i$ to $\mathcal P$ and takes what the prover $P^*$ in $\mathcal P$ sends as $m_1$ as $m_1^i$.
        \item Essentially we take the return value of the first round of $\mathcal P$ as our message $m_1^i$.
        \item Finally, $P$ sends all $m_1^i$ to $V$, where $i = 1, \ldots, n$
    \end{itemize}
    \item $V$ chooses a $t$-bit string $s$ at random and sends it to $P$
    \item $P$ forms challenges $c_i$ for $i \in A$, such that $share(c_i) \cup \{share(c_j)|j \in \bar A\}$ is a qualified set in $\Gamma$ consistent with $s$.
    \begin{itemize}
        \item For $i \in A$, $P$ uses it's knowledge of $w(x_i)$ to compute a valid $m_2^i$ for $(m_1^i, c_i)$ by running the prover's algorithm in $\mathcal P$.
        \item $P$ then sends $c_i, m_2^i$ for $i = 1 ,\ldots, n$ to $V$. 
    \end{itemize}
    \item $V$ checks that all conversations $(m_1^i, c_i, m_2^i)$ would lead to acceptance by the verifier in $\mathcal P$
    \begin{itemize}
        \item During this process, $V$ checks that $share(c_i)$ is consistent with secret $s$.
        \item Accept if all true, otherwise reject. 
    \end{itemize}
\end{enumerate}

