\section{Background}
\label{sec:background}

\subsection{Notation}
Throughout this paper, we use $\lambda$ to denote the computational security parameter and $\kappa$ to denote the statistical security parameter. Computational security refers to a cryptographic system's security against a computationally bounded adversary, while statistical security refers to security that is not dependent on the computational power of the adversary but instead on the security that negligible statistical probability provides.

Additionally, we denote by $x \samplefrom \mathcal D$ the sampling of "$x$" from the distribution "$\mathcal D$". 

% We denote by $x \randselect \mathcal D$ the process of sampling "$x$" fro the distribution "$\mathcal D$" using pseudorandom coins derived from a pseudo-random generator (PRG) applied to the seed "$s$". 

\subsection{Disjunctive Zero-Knowledge}

\begin{definition}[NP Relations]
Let $R \subseteq \{0,1\}^* \times \{0,1\}^*$ be a binary relation. Then $w(x) = \{w \mid (x,w) \in R\}$ and $L_R = \{x \mid \exists w, (x,w) \in R\}$. If $(x,w) \in R$, we say that $w$ is a witness for $x$. $R$ is an NP-relation if it fulfils the following two properties:
\begin{enumerate}
    \item \textbf{Polynomially bounded.} We say that $R$ is \textit{polynomially bounded} if there exists a polynomial $p$ such that $|w| \le p(|x|), \forall (x,w) \in R$. 
    \item \textbf{Polynomial-time verification.} There exists a polynomial-time algorithm for deciding membership in $R$. Consequently, $L_R \in NP$. 
\end{enumerate}

Throughout this document, we will use $\mathcal R$ to refer to a binary NP-relation.
\end{definition}

\begin{definition}[Zero-Knowledge]
A proof or argument system $(P,V)$ is zero-knowledge over $\mathcal R$ if there exists a \textit{probabilistic polynomial time} (PPT) simulator $\mathcal S$, such that for all $(x,w) \in R$, the distribution of the output $\mathcal S(1^\lambda, x)$ of the simulator is indistinguishable from the distribution over the conversations generated by the interaction of $P$ and $V$, from the perspective of $V$; we denote this with $\ViewPV$. Conversations between $P$ and $V$ are ordered triples of the form $(a,c,z)$, and are known as \textit{transcripts}.
\end{definition}

Intuitively, this means that $V$ should not learn anything from the transcripts  with $P$ that they cannot already learn on their own by running the simulator $\mathcal S$; they learn nothing new.

\begin{definition}[Disjunctive Zero-Knowledge]
Given a sequence of statements $(x_1,x_2,\ldots, x_l)$, a \textit{disjunctive zero-knowledge proof} is a protocol to prove in zero-knowledge that $x_1 \in \mathcal L_1 \lor x_2 \in \mathcal L_2 \lor \ldots \lor x_l \in \mathcal L_l$, for NP languages $\mathcal L_i$. We term clauses for which the prover has a witness for as \textit{active} clauses. 
\end{definition}

\begin{definition}[Honest-Verifier Zero-Knowledge]
A proof system is \textit{honest-verifier zero-knowledge} if it only requires that $\mathcal S$ is an efficient simulator for honest (non-malicious) probabilistic polynomial time verifier strategies $V$. If $V$ is malicious then the distribution of the output $\mathcal S(x)$ will no longer be indistinguishable from $\ViewPV$ for such proof systems. 
\end{definition}

\subsection{$\Sigma$-protocols}
\begin{definition}[$\Sigma$-Protocol]
Let $\mathcal R$ be an NP relation. A $\Sigma$-protocol $\Pi = (A, Z, \phi)$ for $\mathcal R$ is a 3-round protocol between a prover algorithm $P$ and a verifier algorithm $V$. The protocol consists of a tuple of probabilistic polynomial time algorithms $(A, Z, \phi)$ with the following interfaces:
\begin{itemize}
    \item $a \leftarrow A(x,w; r^p)$ : Given statement $x$, witness $w \in w(x)$, and prover randomness $r^p$ as input; output the first message $a$ that $P$ sends to $V$ in the first round. 
    \item $c \samplefrom \{0,1\}^\kappa$: $V$ samples a random challenge $c$ and sends it to $P$ in the second round. 
    \item $z \leftarrow Z(x,w,c; r^p)$: Given $x$, $w$, $c$, and $r^p$ as input; output the message $z$ that $P$ sends to $V$ in the third round.
    \item $b \leftarrow \phi(x,a,c,z)$: Given $x$, and the messages in the transcript, output a bit $b \in \{0,1\}$. This algorithm is executed by $V$, and $V$ accepts if $b = 1$.
\end{itemize}
A $\Sigma$-protocol has the following properties:
\begin{enumerate}
    \item \textbf{Completeness.} $\Pi$ is complete if for any $x$, $w \in w(x)$, and any prover randomness $r^p \samplefrom \{0,1\}^\lambda$, the verifier accepts with probability 1. 
    \begin{gather*}
        Pr\left[\phi(x,a,c,z) = 1 \st a \leftarrow A(x,w;r^p); c\samplefrom \{0,1\}^\kappa; z \rightarrow Z(x,w,c;r^p)\right] = 1
    \end{gather*}
    \item \textbf{Special Soundness.} $\Pi$ is said to have special soundness if  there exists a PPT extractor $\mathcal E$, such that given any two transcripts $(a,c,z)$ and $(a,c',z')$ for statement $x$, where $c \ne c'$ and $\phi(x,a,c,z) = \phi(x,a,c',z') = 1$, an element of $w(x)$ can be computed by $\mathcal E$.
    \item \textbf{Special Honest-Verifier Zero-Knowledge.} $\Pi$ is SHVZK if there exists a PPT simulator $\mathcal S$, such that for any $x$, $w$, $(x,w) \in \mathcal R$, the distribution over the output $\mathcal S(1^\lambda, x, c^*)$ is indistinguishable from the distribution over transcripts produced by the interaction between $V$ and $P$ when the challenge is $c^*$.
    \begin{multline*}
        \{(a, z) \mid c^* \samplefrom \{0,1\}^\kappa; (a,z) \leftarrow \mathcal S(1^\lambda,x,c^*)\} 
        \approx_{c^*} \\
        \{(a,z) \mid r^p \samplefrom \{0,1\}^\lambda; a \leftarrow A(x,w;r^p); c^* \samplefrom \{0,1\}^\kappa; z \leftarrow Z(x,w,c^*;r^p)\}
    \end{multline*}
\end{enumerate}
\end{definition}

\begin{definition}[Witness Indistinguishable (WI)]
A $\Sigma$-protocol is witness indistinguishable over $\mathcal R$ if for any $V'$, any large enough input $x$, any $w_1,w_2 \in w(x)$, and for any fixed challenge $c^*$, the distribution over transcripts in the form $(a_1, c, z_1)$ and $(a_2,c,z_2)$ are indistinguishable, where $a_i \leftarrow A(x,w_i;r^p)$ and $z_i \leftarrow Z(x,w_i, c^*; r^p)$ for $i \in \{1,2\}$. This means that the prover reveals no information about which are the active clauses. 
\end{definition}

\begin{definition}[Informal definition of Witness Hiding (WH)]
For any $x$ that is generated with a certain probability distribution by a generator $\mathcal G$ which outputs pairs $(x,w) \in \mathcal R$, a $\Sigma$-protocol is witness hiding over $\mathcal G$, if it does not help even a cheating verifier to compute a witness for $x$ with non-negligible probability. Refer to \cite{10.1145/100216.100272} for details. WH is a weaker property than general zero-knowledge, as it only asserts that the verifier cannot learn about the witness (not asserting anything about other information). That said, it can replace zero-knowledge in many protocol constructions, as it is in most $\Sigma$-protocols.

\end{definition}


\subsection{Schnorr's Identification Protocol}
There are two parties in an \textit{identification scheme}, the prover $P$ and the verifier $V$, and the objective of the protocol is for the prover to convince the verifier that they are who they claim to be. More precisely, $V$ is convinced that $P$ knows the private key that corresponds to the public key of $P$. A familiar example is the standard protocol of password authentication.

Schnorr's protocol \cite{Schnorr} is an identification scheme where $P$ proves knowledge of the discrete log $x$ of a group element $H \in \G$, where $H = x \cdot G$ for some generator $G \in \G$. $(\G, +)$ is a finite abelian group with $+$ as the binary operator\footnote{We have chosen to define $\G$ with the $+$ operator because our implementation uses elliptic curves which are finite abelian groups over addition. The discrete log can be defined equivalently with multiplication like so: $h = g^x$}. The protocol relies on the assumption that finding $x$ given only $H$ and $G$ is computationally difficult -- this is not always the case. The hardness of finding the discrete log depends on the choice of group $\G$ (cite some resource or elaborate). Conversely, proving that $H = x \cdot G$ given $x$ and $G$ can be computed efficiently. 

In our implementation, we plan to use the Ristretto group \cite{ristretto_web}: a construction of a prime order group from a family of elliptic curves known as Edwards curves \cite{Edwards2007}. 

\begin{definition}[Schnorr's Protocol \cite{Schnorr}]
Let $\G = E(\F_q)$, where $E$ is an elliptic curve over the finite field $\F_q$. Suppose that both the prover $P$ and verifier $V$ agree on $E$ and $\F_q$, then let $H \in E(\F_q)$ be the public key that corresponds to the private key $x$ such that $H = x \cdot G$. The prover convinces the verifier that they have knowledge of the private key by doing the following:

\begin{enumerate}
    \item $P$ generates random $r \in \F_q$, and computes the point $\mathcal A = r \cdot G$. $P$ sends the point $\mathcal A$ to $V$.
    \item $V$ computes a random $c \in \F_q$, and sends $c$ to the $P$.
    \item $P$ computes $z = (r + c \cdot x_P) \mod n$, and sends $z$ to the $V$.
    \item $V$ checks that $z \cdot G = \mathcal A + c \cdot H$.
\end{enumerate} 

Evaluating the final equation, we can easily see that $V$ accepts if and only if $x = x_P$. 

\begin{equation*}
    z \cdot G = \mathcal A + c \cdot H \iff
    r \cdot G + c \cdot x_P \cdot G  = r \cdot G + c \cdot x \cdot G \iff
    x  =  x_P
\end{equation*}
\end{definition}


\textbf{A simulator for Schnorr's protocol.} We construct a simulator for Schnorr's protocol by running it "in reverse":

\begin{center}
    \begin{problem}[]{Let our simulator be $S(H)$}
    $z \samplefrom \F_q$ 
    
    $c \samplefrom \F_q$
    
    $\mathcal A = z \cdot G - c \cdot H$
    \tcblower
    \textbf{output} $(\mathcal A,c,z)$
    \end{problem}
\end{center}

Since $z$ and $c$ are both chosen randomly, the resulting $\mathcal A$ is also random, and our output will have the same distribution as the distribution over transcripts in an actual interaction.

\subsection{Shamir's Secret Sharing Scheme}
A \textit{secret sharing scheme} is a method of distributing a secret $s$ to $n$ participants in a way that no one participant has intelligible information about the secret. This is achieved by splitting up $s$ into \textit{shares}, distributing one share to each participant in a way that a subset of participants can reconstruct $s$. Subsets that can reconstruct the secret are called \textit{qualified sets}. For \textit{perfect} secret sharing schemes, like Shamir's, participants in the complement \textit{non-qualified} sets cannot obtain any information about the secret.

Shamir's secret sharing scheme \cite{DBLP:journals/cacm/Shamir79} is also what is known as a \textit{threshold sharing scheme}. These are schemes that produce  qualified sets of size $d$. Any $d$ out of $n$ participants can reconstruct the secret; with $d-1$ shares and less, no  information about the secret can be obtained. 

\subsection{CDS94 Compiler}


In our implementation, we will use Schnorr's discrete log protocol over Ristretto25519 and Shamir's secret sharing scheme to demonstrate the compilation of $\Sigma$-protocol into a $\Sigma$-protocol for the disjunction of $n$ statements. 

We will attempt to make the implementation as general as possible to open up for the future possibility to take any $\Sigma$-protocol that suits our requirements and transform it disjunctive zero-knowledge $\Sigma$-protocol.

\subsubsection{The Witness Indistinguishable (WI) compilation}

In their paper, Cramer {\em{et al}} \cite{CDS94} presents 2 primary ways to construct a WI protocol from a $\Sigma$-protocol $\mathcal P$ (Theorem 8 and 9). 

\begin{itemize}
    \item Theorem 8 requires a smooth secret sharing scheme, and a HVZK $\Sigma$-protocol, while
    \item Theorem 9 requires special honest-verifier ZK (SHVZK) with at least a semi-smooth secret sharing scheme.
\end{itemize}

Since, SSS is a smooth threshold secret sharing scheme (required for 8), and Schnorr's protocol is SHVZK (required for 9), we can choose either construction. 
\textit{We will use \textbf{Theorem 8} in this project.}

\textbf{Theorem 8 \cite{CDS94}}. Given $\mathcal P$, $R_\Gamma$, $\Gamma$, and $\mathcal S(k)$ where

\begin{itemize}
    \item $\mathcal P$ is a 3-round public coin ($\Sigma$-protocol) HVZK proof of knowledge for relation $R$, which satisfies the special soundness property.
    \item $\Gamma = \{ \Gamma(k) \}$ is a family of monotone access structures
    \item $\{\mathcal S(k)\}$ is a family of smooth secret sharing schemes such that the access structure of $\mathcal S(k)$ is $\Gamma(k)^*$
    \item $R_\Gamma$ is a relation where $((x_1,\ldots,x_m),(w_1,\ldots,w_m)) \in R_\Gamma$ if and only if ($\iff$)
    \begin{itemize}
        \item all $x_i$'s are of the same length $k$, and 
        \item the set of indices $i$ for which $(x_i,w_i) \in R$ corresponds to a qualified set in $\Gamma(k)$
    \end{itemize}
\end{itemize}

Then, there exists a $\Sigma$-protocol that is witness indistinguishable for the relation $R_\Gamma$. (The proof of Theorem 8 and 9 is given in their paper.)

\subsubsection{Protocol Description}
Let $A \in \Gamma$ denote the set of indices $i$ for which our prover $P$ knows a witness for $x_i$

\begin{enumerate}
    \item For each $i \in \bar A$, $P$ runs a simulator on input $x_i$ to produce transcripts of conversations in the form $(m_1^i, c_i, m_2^i)$.
    \begin{itemize}
        \item For each $i \in A$, $P$ inputs the witness $w_i$ for $x_i$ to $\mathcal P$ and takes what the prover $P^*$ in $\mathcal P$ sends as $m_1$ as $m_1^i$.
        \item Essentially we take the return value of the first round of $\mathcal P$ as our message $m_1^i$.
        \item Finally, $P$ sends all $m_1^i$ to $V$, where $i = 1, \ldots, n$
    \end{itemize}
    \item $V$ chooses a $t$-bit string $s$ at random and sends it to $P$
    \item $P$ forms challenges $c_i$ for $i \in A$, such that $share(c_i) \cup \{share(c_j)|j \in \bar A\}$ is a qualified set in $\Gamma$ consistent with $s$.
    \begin{itemize}
        \item For $i \in A$, $P$ uses it's knowledge of $w(x_i)$ to compute a valid $m_2^i$ for $(m_1^i, c_i)$ by running the prover's algorithm in $\mathcal P$.
        \item $P$ then sends $c_i, m_2^i$ for $i = 1 ,\ldots, n$ to $V$. 
    \end{itemize}
    \item $V$ checks that all conversations $(m_1^i, c_i, m_2^i)$ would lead to acceptance by the verifier in $\mathcal P$
    \begin{itemize}
        \item During this process, $V$ checks that $share(c_i)$ is consistent with secret $s$.
        \item Accept if all true, otherwise reject. 
    \end{itemize}
\end{enumerate}

